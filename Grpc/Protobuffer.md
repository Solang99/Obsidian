Protocol buffers are Google's language for serializing structured data (like XML or JSON but smaller, faster and simpler)

### Problem solved by Protocol Buffers
Protocol buffer provide a serialization format for packets of typed, structured data and more. This format is suitable for both network traffic and long-term data storage.

Some of the advantages of protobuffers include:
- Compact data storage
- Fast parsing
- Availability in many programming languages
- Optimized functionality through automatically-generated classes

### When are Protocol Buffers not a good fit?
- Protocol buffers assume that the entire message can be loaded into memory at once, so for data that exceeds a few megabytes  it's better to use different solutions. When work with larger data you can end up with several copies of the data due to serialized copies which can cause a spike in memory usage.
- When serialized, the same data can have different binary serializations that not allow two compare messages for equality without parsing them.
- Protocol buffer messages are less than maximally efficient in both size and speed for many scientific and engineering uses that involve large, multi-dimensional arrays of floating point numbers.

### How Protocol buffers works
![[protocol-buffers-concepts.png]]

The code generated by protocol buffers provides utility methods to retrieve data from files and streams, extract individual values from the data, check if data exists, serialize data back to a file or stream, and other useful functions.
Example in java
```proto
message Person { 	 
	optional string name = 1;  
	optional int32 id = 2;  
	optional string email = 3;
}
```

Compiling this `.proto` file creates a `Builder` class that you can use to create new instances, as in the following Java code:
```Java
Person john = Person.newBuilder()    .setId(1234)    
.setName("John Doe")    .setEmail("jdoe@example.com")    .build();output = new FileOutputStream(args[0]);john.writeTo(output);

```

### Protocol Buffers Definition Syntax

When defining `.proto` files, you can specify that a field is either  `optional` or `repeated` or `singular`.
After setting the optionality/repeatability of a field you can specify the data type.

A field can also be of
- A `message` so that you can nest parts of the definition, such as for repeating sets of data.
- A `enum` so can specify a set of values to choose from
- A `oneof` with can be used when a message has many optional fields and at most one field will be set at same time
- A `map` to add key-value pairs to your defination

### Field number
After setting optionality and field type, you assign a field number. Field numbers cannot be repurposed or reused. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number.

Each field in the message definition has a **unique number**. These numbers are used to identify your fields in the [message binary format](https://developers.google.com/protocol-buffers/docs/encoding), and should not be changed once your message type is in use. Field numbers in the range 1 through 15 take one byte to encode, including the field number and the field's type (you can find out more about this in [Protocol Buffer Encoding](https://developers.google.com/protocol-buffers/docs/encoding#structure)). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the field numbers 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.